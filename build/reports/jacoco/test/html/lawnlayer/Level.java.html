<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Level.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lawnlayer</a> &gt; <a href="index.source.html" class="el_package">lawnlayer</a> &gt; <span class="el_source">Level.java</span></div><h1>Level.java</h1><pre class="source lang-java linenums">package lawnlayer;

import java.util.Scanner;
import java.io.File;
import java.io.FileNotFoundException;
import processing.data.JSONArray;
import processing.data.JSONObject;
import java.util.ArrayList;

public class Level {

    private App app;
    private double goal;
    private JSONArray enemiesJSON;
    private Enemy[] enemies;
    private Trail trail;
    private double numSoilPix;
    ArrayList&lt;int[]&gt; initialSoilTiles;

    private double percentageGrass;

    ArrayList&lt;int[]&gt; recursionStorer;

    private String filePath;
    private File file;
    private Scanner scan;
    
<span class="fc" id="L28">    private final int TILES_WIDE = 64;</span>
<span class="fc" id="L29">    private final int TILES_TALL = 32;</span>

    private String[][] tileList; 
    private String[][] pixelList;
    private Material[][] materialMatrix;

    public int renderCount;
    
    /**
     * Constructs a level object and initialises variables such as
     * goal, Trail, and enemies.
     * 
     * @param app           the Papplet object
     * @param filePath      filePath to the levels.txt file
     * @param goal          from the config.json file, how much of the level must be covered in grass to win
     * @param enemiesJSON   from the config.json file, a JSONArray containing enemy information
     */
<span class="fc" id="L46">    public Level(App app, String filePath, double goal, JSONArray enemiesJSON) {</span>
<span class="fc" id="L47">        this.app = app;</span>
<span class="fc" id="L48">        this.goal = goal;</span>
<span class="fc" id="L49">        this.enemiesJSON = enemiesJSON;</span>
<span class="fc" id="L50">        this.trail = new Trail(app, app.player);</span>
<span class="fc" id="L51">        this.filePath = filePath;</span>

<span class="fc" id="L53">        this.tileList = new String[TILES_TALL][TILES_WIDE];</span>
<span class="fc" id="L54">        this.materialMatrix = new Material[this.app.HEIGHT - this.app.TOPBAR][this.app.WIDTH];</span>
<span class="fc" id="L55">        this.recursionStorer = new ArrayList&lt;int[]&gt;();</span>
<span class="fc" id="L56">    }</span>

    /* PRIVATE METHODS */

    /**
     * Read in level.txt file and create the level's materialMatrix,
     * as well as initialise and spawn all enemies.
     * &lt;p&gt;
     * Upon first render we also count the initial soil tiles
     * and the inital soil pixels to be used when calculating
     * the progress made in completing the level.
     */
    private void firstRender() {
<span class="fc" id="L69">        this.app.player.reset();</span>
<span class="fc" id="L70">        this.percentageGrass = 0;</span>

        // read in the level.txt file
        try {
<span class="fc" id="L74">            this.file = new File(filePath);</span>
<span class="fc" id="L75">            this.scan = new Scanner(file);</span>
<span class="nc" id="L76">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L77">            System.out.println(&quot;File not found. Please try again.&quot;);</span>
<span class="nc" id="L78">            return;</span>
<span class="fc" id="L79">        }</span>

        // tileList stores string[] for each line in the .txt file in ***TILE DIMENSIONS***
<span class="fc bfc" id="L82" title="All 2 branches covered.">        for (int i = 0; i &lt; TILES_TALL; i++) {</span>
<span class="fc" id="L83">            String line = scan.nextLine();</span>
<span class="fc" id="L84">            tileList[i] = line.split(&quot;&quot;);</span>
        }

        // pixelList stores string[] for each line in the .txt file in ***PIXELS***
<span class="fc" id="L88">        this.pixelList = enlargeMatrix(tileList, 20);</span>
        
        // materialMatrix stores Material[] for each line in the .txt file in ***PIXELS***
<span class="fc bfc" id="L91" title="All 2 branches covered.">        for (int i = 0; i &lt; pixelList.length; i++) {</span>
<span class="fc bfc" id="L92" title="All 2 branches covered.">            for (int j = 0; j &lt; pixelList[0].length; j++) {</span>
<span class="fc bfc" id="L93" title="All 2 branches covered.">                if (pixelList[i][j].equals(&quot;X&quot;)) materialMatrix[i][j] = Material.CONCRETE;</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">                if (pixelList[i][j].equals(&quot; &quot;)) materialMatrix[i][j] = Material.SOIL;                </span>
            }
        }

<span class="fc" id="L98">        this.initialSoilTiles = this.app.currentLevel.returnMaterialTiles(Material.SOIL);</span>
<span class="fc" id="L99">        this.countSoilPix();</span>

        // add enemies to Enemy array
<span class="fc" id="L102">        int numberOfEnemies = this.enemiesJSON.size();</span>
<span class="fc" id="L103">        this.enemies = new Enemy[numberOfEnemies];</span>
<span class="fc bfc" id="L104" title="All 2 branches covered.">        for (int i = 0; i &lt; numberOfEnemies; i++) {</span>
<span class="fc" id="L105">            JSONObject enemy_i = enemiesJSON.getJSONObject(i);</span>
<span class="fc" id="L106">            int type = enemy_i.getInt(&quot;type&quot;);</span>
<span class="fc" id="L107">            String spawnType = enemy_i.getString(&quot;spawn&quot;);</span>
            
<span class="fc" id="L109">            Enemy enemyTemp = null;</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">            if (type == 0) {</span>
<span class="fc" id="L111">                enemyTemp = new Worm(this.app, this.app.worm, spawnType);</span>
<span class="nc bnc" id="L112" title="All 2 branches missed.">            } else if (type == 1) {</span>
<span class="nc" id="L113">                enemyTemp = new Beetle(this.app, this.app.beetle, spawnType);</span>
            }
<span class="pc bpc" id="L115" title="1 of 2 branches missed.">            if (enemyTemp != null) this.enemies[i] = enemyTemp;</span>
        }
<span class="fc" id="L117">    }</span>
    
    private void countSoilPix() {
<span class="fc" id="L120">        this.numSoilPix = 0;</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        for (int i = 0; i &lt; materialMatrix.length; i++) {</span>
<span class="fc bfc" id="L122" title="All 2 branches covered.">            for (int j = 0; j &lt; materialMatrix[0].length; j++) {</span>
<span class="fc" id="L123">                Material pixel = materialMatrix[i][j];</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">                if (pixel == Material.SOIL) this.numSoilPix++;</span>
            }
        }
<span class="fc" id="L127">    }</span>


    /**
     * Calculates how much soil the player has covered
     * with grass.
     * 
     * Each grass pixel is (1/x * 100)% of the map, where
     * x is the number of original soil pixels.
     * If there are n grass pixels, this is (n/x * 100)%.
     */
    private void updatePercentage() {
<span class="fc" id="L139">        double numGrassPix = 0;</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">        for (int i = 0; i &lt; materialMatrix.length; i++) {</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">            for (int j = 0; j &lt; materialMatrix[0].length; j++) {</span>
<span class="fc" id="L142">                Material pixel = materialMatrix[i][j];</span>
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">                if (pixel == Material.GRASS) numGrassPix++;</span>
            }
        }
        
<span class="fc" id="L147">        this.percentageGrass = Math.ceil((numGrassPix/numSoilPix) * 100); </span>
<span class="fc" id="L148">    }</span>

    /* PUBLIC METHODS */
    
    /** 
     * The primary method which runs the game, rendering
     * each material and their PImage at the correct spot 
     * on PApplet and updating enemies every frame.
     * 
     * This method also contains the win condition for the level.
     */
    public void renderLevel() {

        // upon first time rendering the level
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (this.renderCount == 0) this.firstRender();</span>

        // continually rendering each pixel onto the application
<span class="fc" id="L165">        int backgroundY = this.app.TOPBAR;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (int i = 0; i &lt; materialMatrix.length; i += 20) {</span>
<span class="fc" id="L167">            Material[] line = materialMatrix[i];</span>
<span class="fc" id="L168">            int backgroundX = 0; // X needs to reset each line</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">            for (int j = 0; j &lt; line.length; j += 20) {</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">                if (line[j] == Material.CONCRETE) this.app.image(this.app.concrete, backgroundX, backgroundY);</span>
<span class="fc bfc" id="L171" title="All 2 branches covered.">                if (line[j] == Material.SOIL) this.app.image(this.app.soil, backgroundX, backgroundY);</span>
<span class="pc bpc" id="L172" title="1 of 2 branches missed.">                if (line[j] == Material.GRASS) this.app.image(this.app.grass, backgroundX, backgroundY);</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                if (line[j] == Material.GREEN) {</span>
<span class="nc" id="L174">                    this.app.fill(0, 200, 0);</span>
<span class="nc" id="L175">                    this.app.rect(backgroundX, backgroundY, 20, 20);</span>
                }
<span class="pc bpc" id="L177" title="1 of 2 branches missed.">                if (line[j] == Material.RED) {</span>
<span class="nc" id="L178">                    this.app.fill(200, 0, 0);</span>
<span class="nc" id="L179">                    this.app.rect(backgroundX, backgroundY, 20, 20);</span>
                }
<span class="fc" id="L181">                backgroundX += 20;</span>
            }
<span class="fc" id="L183">            backgroundY += 20; // Y needs to increment each line</span>
        }

<span class="fc bfc" id="L186" title="All 2 branches covered.">        for (Enemy eachEnemy : enemies) {</span>
<span class="fc" id="L187">            eachEnemy.tick();</span>
<span class="fc" id="L188">            eachEnemy.draw();</span>
        }

<span class="fc" id="L191">        this.updatePercentage();</span>
<span class="pc bpc" id="L192" title="1 of 2 branches missed.">        if (this.percentageGrass &gt; this.goal) {</span>
<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (this.app.currentLevelNumber + 1 == app.levels.length) {</span>
<span class="nc" id="L194">                this.app.won = true;</span>
            }
<span class="nc" id="L196">            this.app.currentLevelNumber++;</span>
<span class="nc" id="L197">            return;</span>
        }
        
<span class="fc" id="L200">        this.renderCount++;</span>

<span class="fc" id="L202">    }</span>

    // called every frame, but only after player has been updated

    /**
     * Updates the Trail object which deals with green paths
     * along the map.
     * Note that it only appends a new tile once the player has
     * completely moved to another tile.
     */
    public void draw() {
<span class="fc" id="L213">        trail.updatePosition();</span>
<span class="pc bpc" id="L214" title="3 of 4 branches missed.">        if (this.app.player.getTickCounter() == 0 || this.app.player.getTickCounter() == 10) {</span>
<span class="fc" id="L215">            trail.calculateTrails();</span>
        }
<span class="fc" id="L217">    }</span>

    /**
     * Returns the material underneath a specific pixel
     * coordinate (x, y). 
     * 
     * @param x     the x value of the player in pixels
     * @param y     the y value of the player in pixels
     * @return      the material underneath the player at (x, y)
     */
    public Material getMaterialPixel(int x, int y) {
        Material tile;
        try {
<span class="fc" id="L230">            tile = materialMatrix[y - this.app.TOPBAR][x];</span>
<span class="nc" id="L231">        } catch (ArrayIndexOutOfBoundsException e) {</span>
<span class="nc" id="L232">            System.out.println(&quot;Oh no!&quot;);</span>
<span class="nc" id="L233">            return Material.INVALID;</span>
<span class="fc" id="L234">        }</span>
<span class="fc" id="L235">        return tile;</span>
    }

    /**
     * Updates the object (Level.materialMatrix) used to 
     * render every tile onto the map every frame
     * with a specific material at a specific coordinate.
     * Note that these coordinates refer to the initial
     * position (top-left) of the sprite, not the centre.
     * 
     * @param x         the sprite x-coordinate to update
     * @param y         the sprite y-coordinate to update
     * @param material  the material to place at these pixels
     */
    public void updateMaterialMatrix(int x, int y, Material material) {
<span class="nc bnc" id="L250" title="All 2 branches missed.">        for (int i = y - this.app.TOPBAR; i &lt; y - this.app.TOPBAR + 20; i++) {</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            for (int j = x; j &lt; x + 20; j++) {</span>
<span class="nc" id="L252">                this.materialMatrix[i][j] = material;</span>
            }
        }
<span class="nc" id="L255">    }</span>

    /**
     * Returns an ArrayList of all the coordinates in the map
     * which are of type material.
     * Note that the coordinates returned are sprite coordinates.
     * 
     * @param material  material we want the coordinates of
     * @return          an ArrayList of int[2] containing x and y coordinates
     */
    public ArrayList&lt;int[]&gt; returnMaterialTiles(Material material) {
<span class="fc" id="L266">        ArrayList&lt;int[]&gt; materialCoords = new ArrayList&lt;int[]&gt;();</span>
<span class="fc bfc" id="L267" title="All 2 branches covered.">        for (int i = 0; i &lt; materialMatrix.length; i += 20) {</span>
<span class="fc bfc" id="L268" title="All 2 branches covered.">            for (int j = 0; j &lt; materialMatrix[0].length; j += 20) {</span>
<span class="fc bfc" id="L269" title="All 2 branches covered.">                if (materialMatrix[i][j] == material) {</span>
<span class="fc" id="L270">                    materialCoords.add(new int[] {j, i + this.app.TOPBAR});</span>
                }
            }
        }
<span class="fc" id="L274">        return materialCoords;</span>
    }

    /*
    THE FOLLOWING METHODS BELOW ARE ALL RELATED
     - getSurroundingCoords
     - getNearestSurroundingCoords
     - createMaterialsMatrix
     - materialAt
     - checkReflectivityAt
     - checkOppositionAt
     - getMaterialTilesTouched
     - recursiveReplaceMaterial
     - rReplaceMaterialStored
    */

    /**
     * Given a sprite coordinate (x, y), this method
     * returns the sprite coordinates for all 8 
     * surrounding tiles.
     * 
     * @param x the sprite x-coordinate of the centre tile
     * @param y the sprite y-coordinate of the centre tile
     * @return  a matrix of int[] with the coordinates of all 9 positions related to the chosen tile
     */    
    public int[][][] getSurroundingCoords(int x, int y) {
        
        // these are the tile coordinates of the tile sprites surrounding the current tile
        int[] top, topRight, right, bottomRight, bottom, bottomLeft, left, topLeft, current;
<span class="fc" id="L303">        topLeft = new int[] {x - 20, y - 20};</span>
<span class="fc" id="L304">        top = new int[] {x, y - 20};</span>
<span class="fc" id="L305">        topRight = new int[] {x + 20, y - 20};</span>
<span class="fc" id="L306">        left = new int[] {x - 20, y};</span>
<span class="fc" id="L307">        current = new int[] {x, y};</span>
<span class="fc" id="L308">        right = new int[] {x + 20, y};</span>
<span class="fc" id="L309">        bottomRight = new int[] {x + 20, y + 20};</span>
<span class="fc" id="L310">        bottom = new int[] {x, y + 20};</span>
<span class="fc" id="L311">        bottomLeft = new int[] {x - 20, y + 20};</span>

<span class="fc" id="L313">        int[][] row1 = new int[][] {topLeft, top, topRight};</span>
<span class="fc" id="L314">        int[][] row2 = new int[][] {left, current, right};</span>
<span class="fc" id="L315">        int[][] row3 = new int[][] {bottomLeft, bottom, bottomRight};</span>
<span class="fc" id="L316">        int[][][] surroundingCoords = new int[][][] {row1, row2, row3};</span>

<span class="fc" id="L318">        return surroundingCoords;</span>

    }

    /**
     * 
     * 
     * @param x the sprite x-coordinate of the centre tile
     * @param y the sprite y-coordinate of the centre tile
     * @return  a matrix of int[] with the coordinates of all 9 positions related to the chosen tile
     */
    public int[][][] getNearestSurroundingCoords(int x, int y) {
        // these are the tile coordinates of the pixel **CLOSEST** to the ball sprite pixel
        // NOT the tile coordinates of the tile sprite
        int[] top, topRight, right, bottomRight, bottom, bottomLeft, left, topLeft, current;
<span class="fc" id="L333">        topLeft = new int[] {x - 1, y - 1};</span>
<span class="fc" id="L334">        top = new int[] {x, y - 1};</span>
<span class="fc" id="L335">        topRight = new int[] {x + 20, y - 1};</span>
<span class="fc" id="L336">        left = new int[] {x - 1, y};</span>
<span class="fc" id="L337">        current = new int[] {x, y};</span>
<span class="fc" id="L338">        right = new int[] {x + 20, y};</span>
<span class="fc" id="L339">        bottomRight = new int[] {x + 20, y + 20};</span>
<span class="fc" id="L340">        bottom = new int[] {x, y + 20};</span>
<span class="fc" id="L341">        bottomLeft = new int[] {x - 1, y + 20};</span>

<span class="fc" id="L343">        int[][] row1 = new int[][] {topLeft, top, topRight};</span>
<span class="fc" id="L344">        int[][] row2 = new int[][] {left, current, right};</span>
<span class="fc" id="L345">        int[][] row3 = new int[][] {bottomLeft, bottom, bottomRight};</span>
<span class="fc" id="L346">        int[][][] nearestSurroundingCoords = new int[][][] {row1, row2, row3};</span>
        
<span class="fc" id="L348">        return nearestSurroundingCoords;</span>
    }

    public Material[][] createMaterialsMatrix(int[][][] coordsArray) {

        // surroundingMaterials is a 3x3 matrix 
        // element 1: [0, 0] is the material to the top left of the player
        // element 2: [0, 1] is the material above the player
        // element 5: [1, 1] is the current material underneath the player
        // element 9: [2, 2] is the material to the bottom right of the player
        // and so on...

        // coordsArray should be either NearestSurroundingCoords or SurroundingCoords

<span class="fc" id="L362">        Material[][] surroundingMaterials = new Material[3][3];</span>
<span class="fc bfc" id="L363" title="All 2 branches covered.">        for (int i = 0; i &lt; 3; i++) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">            for (int j = 0; j &lt; 3; j++) {</span>
<span class="fc" id="L365">                int[] tile = coordsArray[i][j];</span>
<span class="fc" id="L366">                Material material = this.app.currentLevel.getMaterialPixel(tile[0], tile[1]);</span>
<span class="fc" id="L367">                surroundingMaterials[i][j] = material;</span>
            }
        }

<span class="fc" id="L371">        return surroundingMaterials;</span>

    }

    // returns the surrounding material at any specified direction (1 - 9, like numbers on a keypad)
    public Material materialAt(Material[][] materialArray, int position) {
<span class="fc bfc" id="L377" title="All 2 branches covered.">        if (position == 1) return materialArray[0][0];</span>
<span class="fc bfc" id="L378" title="All 2 branches covered.">        if (position == 2) return materialArray[0][1];</span>
<span class="pc bpc" id="L379" title="1 of 2 branches missed.">        if (position == 3) return materialArray[0][2];</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">        if (position == 4) return materialArray[1][0];</span>
<span class="pc bpc" id="L381" title="1 of 2 branches missed.">        if (position == 5) return materialArray[1][1];</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">        if (position == 6) return materialArray[1][2];</span>
<span class="pc bpc" id="L383" title="1 of 2 branches missed.">        if (position == 7) return materialArray[2][0];</span>
<span class="pc bpc" id="L384" title="1 of 2 branches missed.">        if (position == 8) return materialArray[2][1];</span>
<span class="nc bnc" id="L385" title="All 2 branches missed.">        if (position == 9) return materialArray[2][2];</span>
<span class="nc" id="L386">        else return Material.INVALID;</span>
    }

    public boolean checkReflectivityAt(Material[][] materialArray, int position) {
<span class="pc bpc" id="L390" title="1 of 2 branches missed.">        if (this.materialAt(materialArray, position) == Material.GRASS ||</span>
<span class="fc bfc" id="L391" title="All 2 branches covered.">            this.materialAt(materialArray, position) == Material.CONCRETE) return true;</span>
<span class="fc" id="L392">        else return false;</span>
    }

    public boolean checkOppositionAt(Material[][] materialArray, int cornerPosition) {
<span class="fc bfc" id="L396" title="All 2 branches covered.">        if (cornerPosition == 1) {</span>
            // check 1, 2, and 4 are ALL concrete or ALL grass
<span class="pc bpc" id="L398" title="1 of 2 branches missed.">            if ((materialAt(materialArray, 1) == Material.CONCRETE &amp;&amp; </span>
<span class="nc bnc" id="L399" title="All 2 branches missed.">                materialAt(materialArray,2) == Material.CONCRETE &amp;&amp; </span>
<span class="pc bnc" id="L400" title="All 2 branches missed.">                materialAt(materialArray, 4) == Material.CONCRETE) ||</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">                (materialAt(materialArray, 1) == Material.GRASS &amp;&amp; </span>
<span class="nc bnc" id="L402" title="All 2 branches missed.">                materialAt(materialArray, 2) == Material.GRASS &amp;&amp;</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">                materialAt(materialArray, 4) == Material.GRASS)) return true;</span>
<span class="fc" id="L404">            else return false;</span>

<span class="pc bpc" id="L406" title="1 of 2 branches missed.">        } else if (cornerPosition == 3) {</span>
            // check 2, 3 and 6
<span class="nc bnc" id="L408" title="All 2 branches missed.">            if ((materialAt(materialArray, 2) == Material.CONCRETE &amp;&amp; </span>
<span class="nc bnc" id="L409" title="All 2 branches missed.">                materialAt(materialArray,3) == Material.CONCRETE &amp;&amp; </span>
<span class="nc bnc" id="L410" title="All 2 branches missed.">                materialAt(materialArray, 6) == Material.CONCRETE) ||</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">                (materialAt(materialArray, 2) == Material.GRASS &amp;&amp; </span>
<span class="nc bnc" id="L412" title="All 2 branches missed.">                materialAt(materialArray, 3) == Material.GRASS &amp;&amp;</span>
<span class="nc bnc" id="L413" title="All 2 branches missed.">                materialAt(materialArray, 6) == Material.GRASS)) return true;</span>
<span class="nc" id="L414">            else return false;</span>

<span class="pc bpc" id="L416" title="1 of 2 branches missed.">        } else if (cornerPosition == 7) {</span>
            // check 4, 7, and 8
<span class="nc bnc" id="L418" title="All 2 branches missed.">            if ((materialAt(materialArray, 4) == Material.CONCRETE &amp;&amp; </span>
<span class="nc bnc" id="L419" title="All 2 branches missed.">                materialAt(materialArray,7) == Material.CONCRETE &amp;&amp; </span>
<span class="nc bnc" id="L420" title="All 2 branches missed.">                materialAt(materialArray, 8) == Material.CONCRETE) ||</span>
<span class="nc bnc" id="L421" title="All 2 branches missed.">                (materialAt(materialArray, 4) == Material.GRASS &amp;&amp; </span>
<span class="nc bnc" id="L422" title="All 2 branches missed.">                materialAt(materialArray, 7) == Material.GRASS &amp;&amp;</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">                materialAt(materialArray, 8) == Material.GRASS)) return true;</span>
<span class="nc" id="L424">            else return false;</span>

<span class="pc bpc" id="L426" title="1 of 2 branches missed.">        } else if (cornerPosition == 9) {</span>
            // check 6, 8, and 9
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">            if ((materialAt(materialArray, 6) == Material.CONCRETE &amp;&amp; </span>
<span class="nc bnc" id="L429" title="All 2 branches missed.">                materialAt(materialArray,8) == Material.CONCRETE &amp;&amp; </span>
<span class="pc bnc" id="L430" title="All 2 branches missed.">                materialAt(materialArray, 9) == Material.CONCRETE) ||</span>
<span class="pc bpc" id="L431" title="1 of 2 branches missed.">                (materialAt(materialArray, 6) == Material.GRASS &amp;&amp; </span>
<span class="nc bnc" id="L432" title="All 2 branches missed.">                materialAt(materialArray, 8) == Material.GRASS &amp;&amp;</span>
<span class="nc bnc" id="L433" title="All 2 branches missed.">                materialAt(materialArray, 9) == Material.GRASS)) return true;</span>
<span class="fc" id="L434">            else return false;</span>
        }
<span class="nc" id="L436">        else return false;</span>
    }

    public ArrayList&lt;int[]&gt; getMaterialTilesTouched(Material material, int x, int y) {
<span class="fc" id="L440">        int[][][] nearestSurroundingCoords = this.getNearestSurroundingCoords(x, y);</span>
<span class="fc" id="L441">        int[][][] surroundingCoords = this.getSurroundingCoords(x, y);</span>
<span class="fc" id="L442">        Material[][] nearestMaterials = this.createMaterialsMatrix(nearestSurroundingCoords);</span>
        
<span class="fc" id="L444">        ArrayList&lt;int[]&gt; tilesTouched = new ArrayList&lt;int[]&gt;();</span>
        
<span class="fc bfc" id="L446" title="All 2 branches covered.">        for (int i = 0; i &lt; nearestMaterials.length; i++) {</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">            for (int j = 0; j &lt; nearestMaterials[0].length; j++) {</span>
<span class="pc bpc" id="L448" title="1 of 2 branches missed.">                if (nearestMaterials[i][j] == material) {</span>
<span class="nc" id="L449">                    int[] tile = surroundingCoords[i][j];</span>
<span class="nc" id="L450">                    tilesTouched.add(tile);</span>
                }
            }
        }
<span class="fc" id="L454">        return tilesTouched;</span>
    }

    // used to replace all green tiles with red tiles when an enemy hits the trail
    public boolean recursiveReplaceMaterial(int[] tile, Material oldMaterial, Material newMaterial) {
<span class="fc" id="L459">        ArrayList&lt;int[]&gt; oldMaterialTilesTouched = app.currentLevel.getMaterialTilesTouched(oldMaterial, tile[0], tile[1]);</span>
<span class="pc bpc" id="L460" title="1 of 2 branches missed.">        if (oldMaterialTilesTouched.isEmpty()) return false;  </span>

<span class="nc bnc" id="L462" title="All 2 branches missed.">        for (int[] materialTile : oldMaterialTilesTouched) {</span>
<span class="nc" id="L463">            this.app.currentLevel.updateMaterialMatrix(materialTile[0], materialTile[1], newMaterial);</span>
<span class="nc" id="L464">            recursiveReplaceMaterial(materialTile, oldMaterial, newMaterial);</span>
<span class="nc" id="L465">        }</span>

<span class="nc" id="L467">        return true;</span>
        
    }

    public ArrayList&lt;int[]&gt; rReplaceMaterialStored(int[] tile, Material oldMaterial, Material newMaterial) {        
<span class="nc" id="L472">        ArrayList&lt;int[]&gt; oldMaterialTilesTouched = app.currentLevel.getMaterialTilesTouched(oldMaterial, tile[0], tile[1]);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">        if (oldMaterialTilesTouched.isEmpty()) return null;  </span>

<span class="nc bnc" id="L475" title="All 2 branches missed.">        for (int[] materialTile : oldMaterialTilesTouched) {</span>
<span class="nc" id="L476">            this.app.currentLevel.updateMaterialMatrix(materialTile[0], materialTile[1], newMaterial);</span>
<span class="nc" id="L477">            this.recursionStorer.add(materialTile);</span>
<span class="nc" id="L478">            rReplaceMaterialStored(materialTile, oldMaterial, newMaterial);</span>
<span class="nc" id="L479">        }</span>

<span class="nc" id="L481">        return this.recursionStorer;</span>
        
    }

    public double getPercentageGrass() {
<span class="fc" id="L486">        return this.percentageGrass;</span>
    }
    public double getGoal() {
<span class="fc" id="L489">        return this.goal;</span>
    }
    public void resetRenderCount() {
<span class="nc" id="L492">        this.renderCount = 0;</span>
<span class="nc" id="L493">    }</span>
    public Enemy[] getEnemyArray() {
<span class="nc" id="L495">        return this.enemies;</span>
    }
    public void resetRecursionStorer() {
<span class="nc" id="L498">        this.recursionStorer = new ArrayList&lt;int[]&gt;();</span>
<span class="nc" id="L499">    }</span>
    public ArrayList&lt;int[]&gt; getInitialSoilTiles() {
<span class="nc" id="L501">        return initialSoilTiles;</span>
    }

    /**
     * Enlarges a tile matrix into a pixel matrix,
     * given a tileSize.
     * 
     * &lt;p&gt;
     * 
     * The following algorithm turns a tile matrix such as
     * 
     * [[&quot;C&quot;, &quot;C&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;S&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;]]
     * 
     * into a pixel matrix such as
     * 
     * [[&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;S&quot;, &quot;S&quot;, &quot;S&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;],
     *  [&quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;, &quot;C&quot;]]
     * 
     * depending on the tileSize.
     * 
    */
    public String[][] enlargeMatrix(String[][] smallMatrix, int tileSize) {
        
<span class="fc" id="L533">        int newHeight = smallMatrix.length * tileSize;</span>
<span class="fc" id="L534">        int newWidth = smallMatrix[0].length * tileSize;</span>
<span class="fc" id="L535">        String[][] bigMatrix = new String[newHeight][newWidth];</span>
        
<span class="fc" id="L537">        int newY = 0;</span>
<span class="fc bfc" id="L538" title="All 2 branches covered.">        for (int i = 0; i &lt; smallMatrix.length; i++) {</span>
<span class="fc" id="L539">            int newX = 0;</span>
<span class="fc bfc" id="L540" title="All 2 branches covered.">            for (int j = 0; j &lt; smallMatrix[i].length; j++) {</span>
<span class="fc" id="L541">                String tile = smallMatrix[i][j];</span>
<span class="fc bfc" id="L542" title="All 2 branches covered.">                for (int k = newY; k &lt; newY+tileSize; k++) {</span>
<span class="fc bfc" id="L543" title="All 2 branches covered.">                    for (int l = newX; l &lt; newX+tileSize; l++) {</span>
<span class="fc" id="L544">                        bigMatrix[k][l] = tile;</span>
                    }
                }
<span class="fc" id="L547">                newX += tileSize;</span>
            }
<span class="fc" id="L549">            newY += tileSize;</span>
        }

<span class="fc" id="L552">        return bigMatrix;</span>

    }

}



</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>