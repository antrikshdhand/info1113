<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Enemy.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lawnlayer</a> &gt; <a href="index.source.html" class="el_package">lawnlayer</a> &gt; <span class="el_source">Enemy.java</span></div><h1>Enemy.java</h1><pre class="source lang-java linenums">package lawnlayer;

import java.util.ArrayList;
import java.util.Random;
import processing.core.PImage;

public abstract class Enemy extends Mover {
    
    protected String spawnType;
    protected boolean hasCollided;

    /**
     * Constructor for the abstract class Enemy which
     * spawns the enemy mob based on the spawnType.
     * 
     * &lt;p&gt;
     * If spawnType is random, a random soil pixel will be 
     * chosen for spawn; if spawnType is a tile coordinate, 
     * a random soil pixel on that tile is chosen for spawn.
     * Spawn direction is randomised.
     * 
     * @param app           The PApplet object
     * @param sprite        The PImage used for the sprite of the enemy
     * @param spawnType     Either &quot;random&quot; or a tile coordinate
     */
    public Enemy(App app, PImage sprite, String spawnType) {
<span class="fc" id="L27">        super(app, sprite);</span>
<span class="fc" id="L28">        this.spawnType = spawnType;</span>
<span class="fc" id="L29">        this.spawnEnemy(spawnType);</span>
       
        // pick a random direction for the sprite to move in
<span class="fc" id="L32">        Direction[] directionArray = new Direction[] {Direction.NE, Direction.SE, Direction.SW, Direction.NW};</span>
<span class="fc" id="L33">        Random rand = new Random();</span>
<span class="fc" id="L34">        this.direction = directionArray[rand.nextInt(directionArray.length)];</span>

<span class="fc" id="L36">    }</span>

    private void spawnEnemy(String spawnType) {

        // TWO SPAWN TYPES
        // 1. RANDOM
        // 2. COORDINATE

<span class="pc bpc" id="L44" title="1 of 2 branches missed.">        if (spawnType.equals(&quot;random&quot;)) {</span>
            // need to spawn on a random soil pixel
<span class="fc" id="L46">            ArrayList&lt;int[]&gt; soilTiles = super.app.currentLevel.returnMaterialTiles(Material.SOIL);</span>
            
<span class="fc" id="L48">            Random r = new Random();        </span>
<span class="fc" id="L49">            int[] randomSoilPixel = soilTiles.get(r.nextInt(soilTiles.size()));</span>
<span class="fc" id="L50">            this.x = randomSoilPixel[0];</span>
<span class="fc" id="L51">            this.y = randomSoilPixel[1];</span>
<span class="fc" id="L52">        } else {</span>
<span class="nc" id="L53">            String[] tileCoordinates = spawnType.split(&quot;,&quot;);</span>
<span class="nc" id="L54">            int tileX = Integer.parseInt(tileCoordinates[0]);</span>
<span class="nc" id="L55">            int tileY = Integer.parseInt(tileCoordinates[1]);</span>
            
            // tileX * 20           &lt;=  pixelX  &lt; tileX * 20 + 20
            // tileY * 20 + TOPBAR  &lt;=  pixelY  &lt; tileY * 20 + TOPBAR + 20
<span class="nc" id="L59">            int baseX = tileX*20;</span>
<span class="nc" id="L60">            int baseY = tileY*20 + this.app.TOPBAR;</span>
<span class="nc" id="L61">            Random randAdd = new Random();</span>
<span class="nc" id="L62">            int pixelX = baseX + randAdd.nextInt(20);</span>
<span class="nc" id="L63">            int pixelY = baseY + randAdd.nextInt(20);</span>
<span class="nc" id="L64">            this.x = pixelX;</span>
<span class="nc" id="L65">            this.y = pixelY;</span>
        }
<span class="fc" id="L67">    }</span>

    public void goNE() {
<span class="nc" id="L70">        this.direction = Direction.NE;</span>
<span class="nc" id="L71">    }</span>

    public void goSE() {
<span class="nc" id="L74">        this.direction = Direction.SE;</span>
<span class="nc" id="L75">    }</span>
    
    public void goSW() {
<span class="nc" id="L78">        this.direction = Direction.SW;</span>
<span class="nc" id="L79">    }</span>
    
    public void goNW() {
<span class="fc" id="L82">        this.direction = Direction.NW;</span>
<span class="fc" id="L83">    }</span>

    /**
     * Based on the current direction of travel, this method
     * controls an enemy's movement upon colliding with a wall 
     * or a grass tile.
     */
    private void checkReflections() {

<span class="fc" id="L92">        int[][][] surroundingCoords = app.currentLevel.getNearestSurroundingCoords(this.x, this.y);</span>
<span class="fc" id="L93">        Material[][] surMat = app.currentLevel.createMaterialsMatrix(surroundingCoords);</span>

<span class="pc bpc" id="L95" title="1 of 2 branches missed.">        if (this.direction == Direction.NE) {</span>
            // if the material above is reflectable, reflect over x-axis
<span class="nc bnc" id="L97" title="All 2 branches missed.">            if (app.currentLevel.checkReflectivityAt(surMat, 2)) {</span>
<span class="nc" id="L98">                this.goSE();</span>
<span class="nc" id="L99">                return;</span>
            }
            // if the material to the right is reflectable, reflect over y-axis
<span class="nc bnc" id="L102" title="All 2 branches missed.">            if (app.currentLevel.checkReflectivityAt(surMat, 6)) {</span>
<span class="nc" id="L103">                this.goNW();</span>
<span class="nc" id="L104">                return;</span>
            }
            // if materials at top right (3) are reflectable, go opposite
<span class="nc bnc" id="L107" title="All 2 branches missed.">            if (app.currentLevel.checkOppositionAt(surMat, 3)) {</span>
<span class="nc" id="L108">                this.goSW();</span>
<span class="nc" id="L109">                return;</span>
            }
<span class="fc bfc" id="L111" title="All 2 branches covered.">        } else if (this.direction == Direction.SE) {</span>
            // if the material below is reflectable, reflect over x-axis
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">            if (app.currentLevel.checkReflectivityAt(surMat, 8)) {</span>
<span class="nc" id="L114">                this.goNE();</span>
<span class="nc" id="L115">                return;</span>
            }
            // if the material to the right is reflectable, reflect over y-axis
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">            if (app.currentLevel.checkReflectivityAt(surMat, 6)) {</span>
<span class="nc" id="L119">                this.goSW();</span>
<span class="nc" id="L120">                return;</span>
            }
            // if materials at bottom right (9) are reflectable, go opposite
<span class="pc bpc" id="L123" title="1 of 2 branches missed.">            if (app.currentLevel.checkOppositionAt(surMat, 9)) {</span>
<span class="nc" id="L124">                this.goNW();</span>
<span class="nc" id="L125">                return;</span>
            }
<span class="fc bfc" id="L127" title="All 2 branches covered.">        } else if (this.direction == Direction.SW) {</span>
            // if the material below is reflectable, reflect over x-axis
<span class="pc bpc" id="L129" title="1 of 2 branches missed.">            if (app.currentLevel.checkReflectivityAt(surMat, 8)) {</span>
<span class="fc" id="L130">                this.goNW();</span>
<span class="fc" id="L131">                return;</span>
            }
            // if the material to the left is reflectable, reflect over y-axis
<span class="nc bnc" id="L134" title="All 2 branches missed.">            if (app.currentLevel.checkReflectivityAt(surMat, 4)) {</span>
<span class="nc" id="L135">                this.goSE();</span>
<span class="nc" id="L136">                return;</span>
            }
            // if materials at bottom left (7) are reflectable, go opposite
<span class="nc bnc" id="L139" title="All 2 branches missed.">            if (app.currentLevel.checkOppositionAt(surMat, 7)) {</span>
<span class="nc" id="L140">                this.goNE();</span>
<span class="nc" id="L141">                return;</span>
            }
<span class="pc bpc" id="L143" title="1 of 2 branches missed.">        } else if (this.direction == Direction.NW) {</span>
            // if the material above is reflectable, reflect over x-axis
<span class="pc bpc" id="L145" title="1 of 2 branches missed.">            if (app.currentLevel.checkReflectivityAt(surMat, 2)) {</span>
<span class="nc" id="L146">                this.goSW();</span>
<span class="nc" id="L147">                return;</span>
            }
            // if the material to the left is reflectable, reflect over y-axis
<span class="pc bpc" id="L150" title="1 of 2 branches missed.">            if (app.currentLevel.checkReflectivityAt(surMat, 4)) {</span>
<span class="nc" id="L151">                this.goNE();</span>
<span class="nc" id="L152">                return;</span>
            }
            // if materials at top left (1) are reflectable, go opposite
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">            if (app.currentLevel.checkOppositionAt(surMat, 1)) {</span>
<span class="nc" id="L156">                this.goNE();</span>
<span class="nc" id="L157">                return;</span>
            }
        }
<span class="fc" id="L160">    }</span>

    /**
     * Basic diagonal movement implementation.
     */
    private void move() {
        // basic movement
<span class="pc bpc" id="L167" title="1 of 2 branches missed.">        if (this.direction == Direction.NE) {</span>
<span class="nc" id="L168">            this.x += 2;</span>
<span class="nc" id="L169">            this.y -= 2;</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        } else if (this.direction == Direction.SE) {</span>
<span class="fc" id="L171">            this.x += 2;</span>
<span class="fc" id="L172">            this.y += 2;</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">        } else if (this.direction == Direction.SW) {</span>
<span class="nc" id="L174">            this.x -= 2;</span>
<span class="nc" id="L175">            this.y += 2;</span>
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        } else if (this.direction == Direction.NW) {</span>
<span class="fc" id="L177">            this.x -= 2;</span>
<span class="fc" id="L178">            this.y -= 2;</span>
        }
<span class="fc" id="L180">    }</span>


    // called every frame

    /**
     * Updates the enemy sprite position every frame.
     * &lt;p&gt;
     * Checks for collisions between the enemy sprite
     * and green tiles. If collided, it resets the level.
     * &lt;p&gt;
     * Called every frame from Level.renderLevel()
     */
    public void tick() {

<span class="pc bpc" id="L195" title="1 of 2 branches missed.">        if (this.hasCollided) {</span>
<span class="nc" id="L196">            this.app.player.stop();</span>
<span class="nc" id="L197">            this.app.resetLevel();</span>
<span class="nc" id="L198">            return;</span>
        }

        // check enemy green tile collision
<span class="fc" id="L202">        int[] currentPosition = new int[] {this.x, this.y};</span>
<span class="fc" id="L203">        boolean greenCollision = this.app.currentLevel.recursiveReplaceMaterial(currentPosition, Material.GREEN, Material.RED);</span>
        
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">        if (greenCollision) {</span>
<span class="nc" id="L206">            this.hasCollided = true;</span>
<span class="nc" id="L207">            return;</span>
        }

<span class="fc" id="L210">        this.checkReflections();</span>
<span class="fc" id="L211">        this.move();</span>
        
<span class="fc" id="L213">    }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>