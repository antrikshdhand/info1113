<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Trail.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">lawnlayer</a> &gt; <a href="index.source.html" class="el_package">lawnlayer</a> &gt; <span class="el_source">Trail.java</span></div><h1>Trail.java</h1><pre class="source lang-java linenums">package lawnlayer;

import java.util.ArrayList;
import java.util.Random;

public class Trail {
    
    private App app;
    private Player player;
    
    private Material previousMaterial;
    private Material currentMaterial;
    private Direction direction;
    private int x;
    private int y;

    private ArrayList&lt;int[]&gt; greenTiles;
    private boolean trailMaking; // whether a trail is currently in progress or not

<span class="fc" id="L20">    public Trail(App app, Player player) {</span>
<span class="fc" id="L21">        this.app = app;</span>
<span class="fc" id="L22">        this.player = player;</span>

<span class="fc" id="L24">        this.previousMaterial = player.getPreviousMaterial(); // player always starts on concrete</span>
<span class="fc" id="L25">        this.currentMaterial = player.getCurrentMaterial(); </span>
<span class="fc" id="L26">        this.trailMaking = false;</span>
<span class="fc" id="L27">    }</span>

    // this method is called every frame
    public void updatePosition() {

<span class="fc" id="L32">        this.x = player.getX();</span>
<span class="fc" id="L33">        this.y = player.getY();</span>
<span class="fc" id="L34">        this.direction = player.getDirection();</span>
<span class="fc" id="L35">        this.greenTiles = this.app.currentLevel.returnMaterialTiles(Material.GREEN);</span>
        
        // check if player hit their own trail
<span class="fc" id="L38">        this.crashDetection();</span>

        // update materials
<span class="fc" id="L41">        this.previousMaterial = player.getPreviousMaterial();</span>
<span class="fc" id="L42">        this.currentMaterial = player.getCurrentMaterial();</span>

<span class="fc" id="L44">    }</span>

    // replaces green tile that has been hit with a red tile
    private void crashDetection() {

<span class="fc" id="L49">        int[] tileToRemove = null;</span>

<span class="pc bpc" id="L51" title="1 of 2 branches missed.">        for (int[] tile : this.greenTiles) {</span>
<span class="nc bnc" id="L52" title="All 4 branches missed.">            if (this.direction == Direction.UP &amp;&amp; this.y &gt; tile[1]) {</span>
<span class="nc bnc" id="L53" title="All 4 branches missed.">                if (this.y &lt; tile[1] + 20 &amp;&amp; this.x == tile[0]) tileToRemove = tile; </span>
<span class="nc bnc" id="L54" title="All 4 branches missed.">            } else if (this.direction == Direction.DOWN &amp;&amp; this.y &lt; tile[1]) {</span>
<span class="nc bnc" id="L55" title="All 4 branches missed.">                if (this.y &gt; tile[1] - 20 &amp;&amp; this.x == tile[0]) tileToRemove = tile;</span>
<span class="nc bnc" id="L56" title="All 4 branches missed.">            } else if (this.direction == Direction.RIGHT &amp;&amp; this.x &lt; tile[0]) {</span>
<span class="nc bnc" id="L57" title="All 4 branches missed.">                if (this.x &gt; tile[0] - 20 &amp;&amp; this.y == tile[1]) tileToRemove = tile;</span>
<span class="nc bnc" id="L58" title="All 4 branches missed.">            } else if (this.direction == Direction.LEFT &amp;&amp; this.x &gt; tile[0]) {</span>
<span class="nc bnc" id="L59" title="All 4 branches missed.">                if (this.x &lt; tile[0] + 20 &amp;&amp; this.y == tile[1]) tileToRemove = tile;</span>
            }
<span class="nc" id="L61">        }</span>

<span class="pc bpc" id="L63" title="1 of 2 branches missed.">        if (tileToRemove != null) {</span>
<span class="nc" id="L64">            this.app.fill(200, 0, 0);</span>
<span class="nc" id="L65">            this.app.rect(tileToRemove[0], tileToRemove[1], 20, 20);</span>
            
<span class="nc" id="L67">            this.trailMaking = false;</span>
            //this.app.currentLevel.resetLevel();
<span class="nc" id="L69">            this.app.resetLevel();</span>

<span class="nc" id="L71">            return;</span>
        }

<span class="fc" id="L74">    }</span>

    // this method is called every 10 frames
    public void calculateTrails() {

        // 1. current material == concrete, previous material == concrete --&gt; do nothing
        // 2. current material == soil, previous material == concrete --&gt; begin a trail
        // 3. current material == soil, previous material == soil --&gt; draw a green tile at prior position 
        // 4. current material == concrete, previous material == soil --&gt; fill grass
        // 5. current material == grass, previous material == soil --&gt; fill grass
        // 6. current material == soil, previous material == grass --&gt; begin a trail

        //System.out.print(&quot;Current: &quot; + this.currentMaterial);
        //System.out.println(&quot; Previous: &quot; + this.previousMaterial);

<span class="pc bpc" id="L89" title="1 of 4 branches missed.">        if (this.previousMaterial == Material.CONCRETE &amp;&amp; this.currentMaterial == Material.CONCRETE) {</span>
<span class="fc" id="L90">            this.trailMaking = false; </span>
        }
<span class="pc bpc" id="L92" title="1 of 4 branches missed.">        if (this.previousMaterial == Material.CONCRETE &amp;&amp; this.currentMaterial == Material.SOIL) {</span>
<span class="nc" id="L93">            this.trailMaking = true;</span>
<span class="nc" id="L94">            this.appendTrails();</span>
        }
<span class="pc bpc" id="L96" title="3 of 4 branches missed.">        if (this.previousMaterial == Material.SOIL &amp;&amp; this.currentMaterial == Material.SOIL) {            </span>
            // draw a green trail 
<span class="nc" id="L98">            this.appendTrails();</span>
        }
<span class="pc bpc" id="L100" title="3 of 4 branches missed.">        if (this.previousMaterial == Material.SOIL &amp;&amp; this.currentMaterial == Material.CONCRETE) { </span>
            // convert to grass, and then end the trail
            // this.appendTrails();
<span class="nc" id="L103">            this.fillGrass();</span>
<span class="nc" id="L104">            this.trailMaking = false;</span>
        }
<span class="pc bpc" id="L106" title="3 of 4 branches missed.">        if (this.previousMaterial == Material.SOIL &amp;&amp; this.currentMaterial == Material.GRASS) {</span>
<span class="nc" id="L107">            this.fillGrass();</span>
<span class="nc" id="L108">            this.trailMaking = false;</span>
        }
<span class="pc bpc" id="L110" title="3 of 4 branches missed.">        if (this.previousMaterial == Material.GRASS &amp;&amp; this.currentMaterial == Material.SOIL) {</span>
<span class="nc" id="L111">            this.trailMaking = true;</span>
<span class="nc" id="L112">            this.appendTrails();</span>
        }

<span class="fc" id="L115">    }</span>
    
    private void appendTrails() {

<span class="nc bnc" id="L119" title="All 2 branches missed.">        if (this.trailMaking == false) return;</span>

<span class="nc bnc" id="L121" title="All 2 branches missed.">        if (this.direction == Direction.RIGHT) {</span>
<span class="nc" id="L122">            int[] tileCoords = {this.x - 20, this.y};</span>
<span class="nc" id="L123">            this.app.currentLevel.updateMaterialMatrix(tileCoords[0], tileCoords[1], Material.GREEN);</span>
<span class="nc bnc" id="L124" title="All 2 branches missed.">        } else if (this.direction == Direction.DOWN) {</span>
<span class="nc" id="L125">            int[] tileCoords = {this.x, this.y - 20};</span>
<span class="nc" id="L126">            this.app.currentLevel.updateMaterialMatrix(tileCoords[0], tileCoords[1], Material.GREEN);</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">        } else if (this.direction == Direction.LEFT) {</span>
<span class="nc" id="L128">            int[] tileCoords = {this.x + 20, this.y};</span>
<span class="nc" id="L129">            this.app.currentLevel.updateMaterialMatrix(tileCoords[0], tileCoords[1], Material.GREEN);</span>
<span class="nc bnc" id="L130" title="All 2 branches missed.">        } else if (this.direction == Direction.UP) {</span>
<span class="nc" id="L131">            int[] tileCoords = {this.x, this.y + 20};</span>
<span class="nc" id="L132">            this.app.currentLevel.updateMaterialMatrix(tileCoords[0], tileCoords[1], Material.GREEN);</span>
        }

<span class="nc" id="L135">    }</span>

    private void fillGrass() {

        // set each calculated tile which has been determined to be grass to be grass in the level file
<span class="nc bnc" id="L140" title="All 2 branches missed.">        for (int[] tile : this.calculateGrass()) {</span>
<span class="nc" id="L141">            this.app.currentLevel.updateMaterialMatrix(tile[0], tile[1], Material.GRASS);</span>
<span class="nc" id="L142">        }</span>

        //this.app.currentLevel.resetRecursionStorer();
            
<span class="nc" id="L146">    }</span>

    private ArrayList&lt;int[]&gt; calculateGrass() {
        
<span class="nc" id="L150">        ArrayList&lt;int[]&gt; potentialGrassTiles = new ArrayList&lt;int[]&gt;();</span>

<span class="nc" id="L152">        boolean enemyPresent = true;</span>
<span class="nc" id="L153">        int i = 1;</span>
<span class="nc bnc" id="L154" title="All 4 branches missed.">        while (enemyPresent &amp;&amp; i &lt; 1000) {</span>
<span class="nc" id="L155">            enemyPresent = this.enemyChecker(i);</span>
<span class="nc" id="L156">            i++;</span>
        }

        // convert all green tiles to grass
<span class="nc bnc" id="L160" title="All 2 branches missed.">        for (int[] tile : this.greenTiles) {</span>
<span class="nc" id="L161">            potentialGrassTiles.add(tile);</span>
<span class="nc" id="L162">        }</span>
        
<span class="nc" id="L164">        return potentialGrassTiles;</span>
    }

    private boolean enemyChecker(int i) {

<span class="nc" id="L169">        ArrayList&lt;int[]&gt; allSoilTiles = this.app.currentLevel.getInitialSoilTiles();</span>
<span class="nc" id="L170">        int[] aSoilTile = allSoilTiles.get(i);</span>
        
<span class="nc" id="L172">        ArrayList&lt;int[]&gt; allUpdatedTiles = this.app.currentLevel.rReplaceMaterialStored(aSoilTile, Material.SOIL, Material.GRASS);</span>
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (allUpdatedTiles == null) return true;</span>

        // check if enemy is present in recursive fill
<span class="nc bnc" id="L176" title="All 2 branches missed.">        for (Enemy enemy : this.app.currentLevel.getEnemyArray()) {</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">            for (int[] updatedTile : allUpdatedTiles) {</span>
                // System.out.println(&quot;Tile: &quot; + updatedTile[0] + &quot;, &quot; + updatedTile[1]);
                // System.out.println(&quot;Enemy: &quot; + enemy.getX() + &quot;, &quot; + enemy.getY());
                // System.out.println();
<span class="nc bnc" id="L181" title="All 4 branches missed.">                if ((enemy.getX() &lt; updatedTile[0] + 5 &amp;&amp; enemy.getX() &gt; updatedTile[0] - 5) &amp;&amp;</span>
<span class="nc bnc" id="L182" title="All 4 branches missed.">                    (enemy.getY() &lt; updatedTile[1] + 5 &amp;&amp; enemy.getY() &gt; updatedTile[1] - 5)) {</span>
                    // enemy is present in that segment
<span class="nc" id="L184">                    return true;</span>
                }
<span class="nc" id="L186">            }</span>
        }

<span class="nc" id="L189">        return false;</span>

    }

    private ArrayList&lt;int[]&gt; enemyCheckerReturn(int i) {

        // pick i-th soil tile to begin with and conduct recursive fill
<span class="nc" id="L196">        ArrayList&lt;int[]&gt; allSoilTiles = this.app.currentLevel.returnMaterialTiles(Material.SOIL);</span>
<span class="nc" id="L197">        int[] aSoilTile = allSoilTiles.get(i);</span>

<span class="nc" id="L199">        ArrayList&lt;int[]&gt; allUpdatedTiles = this.app.currentLevel.rReplaceMaterialStored(aSoilTile, Material.SOIL, Material.GRASS);</span>

<span class="nc" id="L201">        return allUpdatedTiles;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>